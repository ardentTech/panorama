package codegen

import lexicon.*
import java.util.*

internal fun String.capitalize(): String {
    return this.replaceFirstChar {
        if (it.isLowerCase()) it.uppercase(Locale.getDefault()) else it.toString()
    }
}

internal fun LexiconDoc.toFile(): KtFile {
    var description: String? = null
    val types = mutableListOf<KtType>()

    defs.map { (key, def) ->
        val name = if (key == "main") {
            description = def.description
            this.name.capitalize()
        } else if (this.name == "defs") key.capitalize()
        else "${this.name}${key.capitalize()}"

        when (def) {
            is LexiconProcedure -> types += def.toTypes(name)
            else -> throw IllegalArgumentException("Unsupported type: ${def::class.simpleName}")
        }
    }

    return KtFile(
        types,
    """
        |This file was generated by Panorama. DO NOT EDIT.
        |
        |Lexicon: ${this.id}
        |Version: ${this.lexicon}
        |Revision: ${this.revision ?: "N/A"}
        |Description: ${description ?: "N/A"}
        |
    """.trimMargin(),
        this.namespace ?: "",
        this.name.capitalize()
    )
}

internal fun LexiconObject.Property.toProperty(isNullable: Boolean, name: String): KtProperty<*> {
    return when (this) {
        //is LexiconArray -> TODO()
        is LexiconString -> KtProperty(String::class, this.default, isNullable, name, this.const)
        else -> throw IllegalArgumentException("TODO")
    }
}

internal fun PrimaryIOSchema.toType(name: String): KtType {
    return when (this) {
        is LexiconObject -> {
            val rawProperties = this.properties.map { (key, value) -> value.toProperty(nullable?.contains(key) == true, key) }.toTypedArray()
            val (properties, parameters) = rawProperties.partition { it.value != null }
            KtType.KtDataClass(
                this.description,
                name,
                parameters.map { KtParameter.from(it) },
                properties
            )
        }
        is LexiconRef -> KtType.KtTypeAlias(name, String::class) // TODO `this.ref` to type reference
        is LexiconUnion -> KtType.KtTypeAlias(name, String::class) // TODO this is a placeholder
    }
}

internal fun PrimaryIO.toType(name: String): KtType? {
    return this.schema?.toType(name)
}

internal fun LexiconProcedure.toTypes(name: String): List<KtType> {
    val types = mutableListOf<KtType>()

    input?.let { io ->
        io.toType("${name}Input")?.let { schema -> types.add(schema) }
    }
//    output?.let {  }
//    errors?.let {  }
    return types
}