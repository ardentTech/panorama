package codegen

import lexicon.*
import java.util.*

internal fun String.capitalize(): String {
    return this.replaceFirstChar {
        if (it.isLowerCase()) it.uppercase(Locale.getDefault()) else it.toString()
    }
}

internal fun LexiconDoc.toFile(): KtFile {
    var description: String? = null
    val types = mutableListOf<KtType>()

    defs.map { (key, def) ->
        val name = if (key == "main") {
            description = def.description
            this.name.capitalize()
        } else if (this.name == "defs") key.capitalize()
        else "${this.name}${key.capitalize()}"

        when (def) {
            is LexiconProcedure -> types += def.toTypes(name)
            else -> throw IllegalArgumentException("Unsupported type: ${def::class.simpleName}")
        }
    }

    return KtFile(
        types,
    """
        |This file was generated by Panorama. DO NOT EDIT.
        |
        |Lexicon: ${this.id}
        |Version: ${this.lexicon}
        |Revision: ${this.revision ?: "N/A"}
        |Description: ${description ?: "N/A"}
        |
    """.trimMargin(),
        this.namespace ?: "",
        this.name.capitalize()
    )
}

internal fun LexiconArray.toMember(isNullable: Boolean, name: String): KtMember<*> {
    val itemCls = when(items) {
        // TODO these aren't all valid
        is LexiconBlob -> String::class
        is LexiconBoolean -> Boolean::class
        is LexiconBytes -> String::class
        is LexiconCidLink -> String::class
        is LexiconInteger -> Int::class
        is LexiconRef -> String::class
        is LexiconString -> String::class
        is LexiconUnion -> String::class
        is LexiconUnknown -> String::class
    }
    return KtMember.KtParameter.KtCollection(List::class, null, isNullable, itemCls, name)
}

internal fun LexiconObject.Property.toMember(isNullable: Boolean, name: String): KtMember<*> {
    return when (this) {
        is LexiconArray -> this.toMember(isNullable, name)
        is LexiconString -> {
            this.const?.let { constant ->
                KtMember.KtProperty.KtItem(String::class, constant, isNullable, name)
            } ?: KtMember.KtParameter.KtItem(String::class, default, isNullable, name)
        }
        // TODO others
        else -> throw IllegalArgumentException("TODO")
    }
}

internal fun PrimaryIOSchema.toType(name: String): KtType {
    return when (this) {
        is LexiconObject -> {
            KtType.KtDataClass(
                this.description,
                this.properties.map { (key, value) -> value.toMember(nullable?.contains(key) == true, key) },
                name,
            )
        }
        is LexiconRef -> KtType.KtTypeAlias(name, String::class) // TODO `this.ref` to type reference
        is LexiconUnion -> KtType.KtTypeAlias(name, String::class) // TODO this is a placeholder
    }
}

internal fun PrimaryIO.toType(name: String): KtType? {
    return this.schema?.toType(name)
}

internal fun LexiconProcedure.toTypes(name: String): List<KtType> {
    val types = mutableListOf<KtType>()

    input?.let { io ->
        io.toType("${name}Input")?.let { schema -> types.add(schema) }
    }
//    output?.let {  }
//    errors?.let {  }
    return types
}