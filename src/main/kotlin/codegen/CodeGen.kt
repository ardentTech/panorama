package codegen

import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import lexicon.*
import java.util.*

// TODO unit test
fun String.capitalize(): String {
    return this.replaceFirstChar {
        if (it.isLowerCase()) it.uppercase(Locale.getDefault()) else it.toString()
    }
}

// TODO unit test
fun String.camelToEnumCase(): String {
    val pattern = "(?<=.)[A-Z]".toRegex()
    return this.replace(pattern, "_$0").uppercase(Locale.getDefault())
}

// TODO unit test
fun String.uncapitalize(): String {
    return this.replaceFirstChar {
        if (it.isUpperCase()) it.lowercase(Locale.getDefault()) else it.toString()
    }
}

interface DocCodeGen {
    fun from(doc: LexiconDoc): Result<Unit>
}

object KotlinPoetCodeGen: DocCodeGen {

    override fun from(doc: LexiconDoc): Result<Unit> {
        return try {
            val specs = mutableListOf<TypeSpec>()
            doc.defs.forEach { (k, v) -> specs += MainCodeGen.from(v, k) }
            buildFile(getFileComment(doc), specs, doc.namespace ?: "", doc.name.capitalize())
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    private fun getFileComment(doc: LexiconDoc) = """
        |This file was generated by Panorama. DO NOT EDIT.
        |
        |Lexicon: ${doc.id}
        |Version: ${doc.lexicon}
        |Revision: ${doc.revision ?: "N/A"}
        |Description: ${doc.description ?: "N/A"}
        |
    """.trimIndent()
}

internal object MainCodeGen {

    // build each as standalone objects
    fun from(def: SchemaDef, name: String): TypeSpec {
        return when (def) {
            is LexiconObject -> ObjectCodeGen.from(def, name)
            is LexiconString -> LexiconStringConverter.toType(def, name)
            is LexiconToken -> LexiconTokenConverter.toType(def, name)
            // TODO procedure, query, record, subscription
            else -> throw IllegalArgumentException("Unsupported root type: ${def::class.simpleName}")
        }
    }
}

internal object ObjectCodeGen {
    fun from(def: LexiconObject, name: String): TypeSpec {
        def.properties.map { (k, v) ->
            val isNullable = def.nullable?.contains(k) == true
            when (v) {
                is LexiconArray -> ParameterCodeGen.from(v, isNullable, k)
                is LexiconBlob -> ParameterCodeGen.from(v, isNullable, k)
                is LexiconBoolean -> v.const?.let { PropertyCodeGen.from(v, k) } ?: ParameterCodeGen.from(v, isNullable, k)
                is LexiconBytes -> ParameterCodeGen.from(v, isNullable, k)
                is LexiconCidLink -> ParameterCodeGen.from(v, isNullable, k)
                is LexiconInteger -> v.const?.let { PropertyCodeGen.from(v, k) } ?: ParameterCodeGen.from(v, isNullable, k)
                is LexiconRef -> ParameterCodeGen.from(v, isNullable, k)
                is LexiconString -> v.const?.let { PropertyCodeGen.from(v, k) } ?: ParameterCodeGen.from(v, isNullable, k)
                is LexiconUnion -> ParameterCodeGen.from(v, isNullable, k)
                is LexiconUnknown -> ParameterCodeGen.from(v, isNullable, k)
                else -> throw IllegalArgumentException("Unsupported property type: ${v::class.simpleName}")
            }
        }
        return buildDataClass(def.description, name, emptyList(), emptyList())
    }
}

internal object ParameterCodeGen {

    // this only has concrete types for now
    fun from(def: SchemaDef, isNullable: Boolean = false, name: String): ParameterSpec {
        return when (def) {
            // TODO array
            is LexiconBlob -> buildParameter(String::class, null, isNullable, name)
            is LexiconBoolean -> LexiconBooleanConverter.toParameter(def, isNullable, name)
            is LexiconBytes -> buildParameter(String::class, null, isNullable, name)
            is LexiconCidLink -> buildParameter(String::class, null, isNullable, name)
            is LexiconInteger -> LexiconIntegerConverter.toParameter(def, isNullable, name)
            // TODO ref
            is LexiconString -> LexiconStringConverter.toParameter(def, isNullable, name)
            // TODO union
            // TODO unknown
            else -> throw IllegalArgumentException("Unsupported parameter type: ${def::class.simpleName}")
        }
    }
}

internal object PropertyCodeGen {

    // this only has concrete types with a `const` property
    // TODO needs isNullable?
    fun from(def: SchemaDef, name: String): PropertySpec {
        return when (def) {
            is LexiconBoolean -> LexiconBooleanConverter.toProperty(def, name)
            is LexiconInteger -> LexiconIntegerConverter.toProperty(def, name)
            is LexiconString -> LexiconStringConverter.toProperty(def, name)
            else -> throw IllegalArgumentException("Unsupported property type: ${def::class.simpleName}")
        }
    }
}