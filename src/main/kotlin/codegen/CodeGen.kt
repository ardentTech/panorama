package codegen

import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.TypeSpec
import lexicon.*

// TODO could have a single `build` function that accepts a SchemaDef and a name and then routes
object CodeGen {

    // TODO create KFile class
    fun from(def: LexiconDoc): FileSpec {
        var description: String? = null
        val lexiconName = def.id.split(".").last().capitalize()
        val specs = mutableListOf<TypeSpec>()

        def.defs.forEach { (defName, schemaDef) ->
//            specs += schemaDef.codegen(
//                if (defName == "main") lexiconName
//                else if (lexiconName == "Defs") defName.capitalize()
//                else "${lexiconName}${defName.capitalize()}"
//            )
            if (defName == "main") description = schemaDef.description
        }

        val file = FileSpec.builder(def.namespace ?: "", lexiconName)
            .addFileComment("""
This file was generated by Panorama. DO NOT EDIT.

Lexicon: ${def.id}
${description?.let { "Description: $it" }}
                    """.trimIndent())

        specs.forEach { file.addType(it) }
        return file.build()
    }

    fun from(def: List<LexiconError>, name: String): TypeSpec {
        return generateKEnum(name, def.map { it.name.camelToEnumCase() })
    }

    fun from(def: LexiconIO, name: String): TypeSpec {
        return def.schema?.let { schema ->
            when (schema) {
                is LexiconObject -> from(schema, name)
                is LexiconRef -> from(schema, name)
                // TODO union
                else -> throw IllegalArgumentException("TODO LexiconIO.codegen() name: $name / schema: $schema")
            }
        } ?: run {
            generateKObject(
                KObjectConfig(
                    name = name, properties = listOf(
                        KBodyPropertyConfig(cls = String::class, name = "encoding", value = def.encoding,)
                    )
                )
            )
        }
    }

    fun from(def: LexiconObject, name: String): TypeSpec {
        val propConfigs = def.properties.map { (key, value) -> KPropConfigFactory.from(value, def.nullable?.contains(key) == true, key) }
        return generateKDataClass(
            KDataClassConfig(
                bodyProperties = propConfigs.filter { it.constantValue != null },
                constructorProperties = propConfigs.filter { it.constantValue == null },
                description = def.description,
                name = name
            )
        )
    }

    fun from(def: LexiconParams, name: String): TypeSpec {
        val propConfigs = def.properties.map { (key, value) -> KPropConfigFactory.from(value, key) }
        return generateKDataClass(
            KDataClassConfig(
                bodyProperties = propConfigs.filter { it.constantValue != null },
                constructorProperties = propConfigs.filter { it.constantValue == null },
                description = def.description,
                name = name
            )
        )
    }

    fun from(def: LexiconProcedure, name: String): List<TypeSpec> {
        val specs = mutableListOf<TypeSpec>()

        // TODO description

        def.input?.let {
            specs += from(it, "${name}Input")
        }

        def.output?.let {
            specs += from(it, "${name}Output")
        }

        def.errors?.let {
            specs += from(it, "${name}Errors")
        }

        return specs.toList()
    }

    fun from(def: LexiconQuery, name: String): List<TypeSpec> {
        val specs = mutableListOf<TypeSpec>()

        // TODO description

        def.parameters?.let {
            specs += CodeGen.from(it, "${name}Params")
        }

        def.output?.let {
            specs += CodeGen.from(it, "${name}Output")
        }

        def.errors?.let {
            specs += CodeGen.from(it, "${name}Errors")
        }

        return specs.toList()
    }

    fun from(def: LexiconRecord, name: String): TypeSpec {
        return generateKDataClass(
            KDataClassConfig(
                bodyProperties = listOf(),
                constructorProperties = listOf(), // invalid
                description = def.description,
                name = name
            )
        )
    }

    fun from(def: LexiconRef, name: String): TypeSpec {
        return generateKDataClass(
            KDataClassConfig(
                constructorProperties = listOf(
                    KPropConfig(cls = String::class, name = "TODO")
                ),
                description = def.description,
                name = name
            )
        )
    }

    fun from(def: LexiconSubscription, name: String): List<TypeSpec> {
        val specs = mutableListOf<TypeSpec>()

        // TODO description

        def.parameters?.let {
            specs += from(it, "${name}Params")
        }

        // TODO message (schema must be a union of refs)
        // this is the output from the web socket

        def.errors?.let {
            specs += from(it, "${name}Errors")
        }

        return specs.toList()
    }

    fun from(def: LexiconToken, name: String): TypeSpec {
        return generateKObject(
            KObjectConfig(
                description = def.description,
                name = name,
                properties = listOf(
                    KBodyPropertyConfig(
                        cls = String::class,
                        name = "code",
                        value = name.uncapitalize(),
                    )
                )
            )
        )
    }
}